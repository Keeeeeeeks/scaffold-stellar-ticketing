'use client';

import {
  createContext,
  useContext,
  useState,
  useEffect,
  useCallback,
  ReactNode,
} from 'react';
import {
  isConnected as freighterIsConnected,
  getAddress,
  signTransaction,
  setAllowed,
  isAllowed,
  requestAccess,
} from '@stellar/freighter-api';

interface WalletContextType {
  address: string | null;
  isConnected: boolean;
  isConnecting: boolean;
  error: string | null;
  network: string;
  connect: () => Promise<void>;
  disconnect: () => void;
  signTx: (xdr: string) => Promise<string>;
}

const WalletContext = createContext<WalletContextType | undefined>(undefined);

export function WalletProvider({ children }: { children: ReactNode }) {
  const [address, setAddress] = useState<string | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [isConnecting, setIsConnecting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [network, setNetwork] = useState(
    process.env.NEXT_PUBLIC_NETWORK || 'testnet'
  );

  // Check connection status on mount
  useEffect(() => {
    const checkConnection = async () => {
      try {
        const connected = await freighterIsConnected();
        if (connected) {
          const allowedResult = await isAllowed();
          if (allowedResult.isAllowed) {
            const addressResult = await getAddress();
            if (addressResult.address) {
              setAddress(addressResult.address);
              setIsConnected(true);
            }
          }
        }
      } catch (err) {
        console.error('Error checking wallet connection:', err);
      }
    };
    checkConnection();
  }, []);

  const connect = useCallback(async () => {
    setIsConnecting(true);
    setError(null);

    try {
      const connected = await freighterIsConnected();

      if (!connected) {
        throw new Error(
          'Freighter wallet is not installed. Please install it from https://freighter.app'
        );
      }

      // Request access
      await requestAccess();

      // Get the address
      const addressResult = await getAddress();

      if (!addressResult.address) {
        throw new Error('Failed to get address from Freighter');
      }

      setAddress(addressResult.address);
      setIsConnected(true);
    } catch (err) {
      const message =
        err instanceof Error ? err.message : 'Failed to connect wallet';
      setError(message);
      console.error('Wallet connection error:', err);
    } finally {
      setIsConnecting(false);
    }
  }, []);

  const disconnect = useCallback(() => {
    setAddress(null);
    setIsConnected(false);
    setError(null);
  }, []);

  const signTx = useCallback(
    async (xdr: string): Promise<string> => {
      if (!isConnected) {
        throw new Error('Wallet not connected');
      }

      try {
        const networkPassphrase =
          network === 'mainnet'
            ? 'Public Global Stellar Network ; September 2015'
            : 'Test SDF Network ; September 2015';

        const result = await signTransaction(xdr, {
          networkPassphrase,
        });

        if (result.error) {
          throw new Error(result.error);
        }

        return result.signedTxXdr;
      } catch (err) {
        const message =
          err instanceof Error ? err.message : 'Failed to sign transaction';
        throw new Error(message);
      }
    },
    [isConnected, network]
  );

  return (
    <WalletContext.Provider
      value={{
        address,
        isConnected,
        isConnecting,
        error,
        network,
        connect,
        disconnect,
        signTx,
      }}
    >
      {children}
    </WalletContext.Provider>
  );
}

export function useWallet() {
  const context = useContext(WalletContext);
  if (context === undefined) {
    throw new Error('useWallet must be used within a WalletProvider');
  }
  return context;
}
