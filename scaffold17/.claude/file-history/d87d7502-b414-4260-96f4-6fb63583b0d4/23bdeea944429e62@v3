import { useState } from "react";
import { useQueryClient } from "@tanstack/react-query";
import { useMultiWallet } from "./useMultiWallet";
import ticketing from "../contracts/ticketing";
import type { PaymentToken } from "ticketing";

export const useTicketContract = () => {
  const { activeAddress, signTransaction, updateBalances } = useMultiWallet();
  const queryClient = useQueryClient();
  const [isPurchasing, setIsPurchasing] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const [txHash, setTxHash] = useState<string | null>(null);

  const purchaseTicket = async (
    eventId: bigint,
    paymentToken: PaymentToken
  ): Promise<number | null> => {
    if (!activeAddress) {
      setError(new Error("No wallet connected"));
      return null;
    }

    setIsPurchasing(true);
    setError(null);
    setTxHash(null);

    try {
      // Build the transaction
      const tx = await ticketing.purchase_ticket(
        {
          event_id: eventId,
          buyer: activeAddress,
          payment_token: paymentToken,
        },
        // @ts-expect-error js-stellar-sdk has bad typings; publicKey is allowed
        { publicKey: activeAddress }
      );

      // Sign and send the transaction
      const result = await tx.signAndSend({
        signTransaction: async (xdr: string) => {
          const signed = await signTransaction(xdr);
          return { signedTxXdr: signed };
        },
      });

      // Store the transaction hash
      if (result.sendTransactionResponse?.hash) {
        setTxHash(result.sendTransactionResponse.hash);
        console.log("Transaction hash:", result.sendTransactionResponse.hash);
      }

      // Get the token ID from the result
      const tokenId = result.result;

      // Invalidate queries to refresh data
      await queryClient.invalidateQueries({ queryKey: ["userTickets"] });
      await queryClient.invalidateQueries({ queryKey: ["events"] });
      await updateBalances();

      return tokenId;
    } catch (err) {
      console.error("Purchase failed:", err);
      const e = err instanceof Error ? err : new Error("Purchase failed");
      setError(e);
      return null;
    } finally {
      setIsPurchasing(false);
    }
  };

  return {
    purchaseTicket,
    isPurchasing,
    error,
    txHash,
  };
};
